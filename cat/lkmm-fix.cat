// SPDX-License-Identifier: GPL-2.0+
(*
 * Copyright (C) 2015 Jade Alglave <j.alglave@ucl.ac.uk>,
 * Copyright (C) 2016 Luc Maranget <luc.maranget@inria.fr> for Inria
 * Copyright (C) 2017 Alan Stern <stern@rowland.harvard.edu>,
 *                    Andrea Parri <parri.andrea@gmail.com>
 *
 * An earlier version of this file appeared in the companion webpage for
 * "Frightening small children and disconcerting grown-ups: Concurrency
 * in the Linux kernel" by Alglave, Maranget, McKenney, Parri, and Stern,
 * which appeared in ASPLOS 2018.
 *)

"Linux-kernel memory consistency model"

(*
 * File "lock.cat" handles locks and is experimental.
 * It can be replaced by include "cos.cat" for tests that do not use locks.
 *)

include "lock.cat"

(* Compute marked and plain memory accesses *)
let Marked = (~M) | IW | Once | Release | Acquire | (RMW & R) | (RMW & W) |
        LKR | LKW | UL | LF | RL | RU
let Plain = M \ Marked

(*******************)
(* Basic relations *)
(*******************)

// Common
let acq-po = [Acquire] ; po ; [M]
let po-rel = [M] ; po ; [Release]
let po-unlock-lock-po = po ; [UL] ; (po|rf) ; [LKR] ; po
let R4rmb = R \ Noreturn
let rmb = [R4rmb] ; po ; [Rmb] ; po ; [R4rmb]
let wmb = [W] ; po ; [Wmb] ; po ; [W]

// Others
let rmb-plain = [R \ Noreturn] ; po ; [Rmb] ; po \ ( po ; [W] ; po-loc) ; [R \ Noreturn]
let plain-wmb = [W] ; po \ (po-loc ; [W] ; po) ; [Wmb] ; po ; [W]
let strong-fence =
       [M] ; po ; [Mb] ; po ; [M]
     | [M] ; po ; [Before-atomic] ; po ; [RMW] ; po? ; [M]
     | [M] ; po? ; [RMW] ; po ; [After-atomic] ; po ; [M]
     | [M] ; po? ; [LKW] ; po ; [After-spinlock] ; po ; [M]
     | [M] ; po ; [UL] ; po ; [LKR] ; po ; [After-unlock-lock] ; po ; [M]
     | [M] ; po? ; [SC] ; po ; [M]
     | [M] ; po ; [SC] ; po? ; [M]
     | po ; [Sync-rcu | Sync-srcu] ; po?
let strong-sync = strong-fence
     | ([M] ; po-unlock-lock-po ; [After-unlock-lock] ; po ; [M])
let fence = strong-fence | po-rel | acq-po | wmb | rmb
let dop = rmb-plain? ; (addr | data | ctrl | rfi)+; plain-wmb?
let to-w = (dop | po-loc) ; [W]
let lrs = ([W] ; po-loc ; [R]) \ (po-loc ; [W] ; po-loc)
let to-r = addr | ((addr | data) ; lrs)
let ppo = to-r | to-w | fence | (po ; [UL] ; po ; [LKR] ; po)

let cumul-fence = [Marked] ; (rfe? ; (po-rel ; (rfe ; rmw)*) | wmb | po-unlock-lock-po) ; [Marked]
let prop = [Marked] ; ((co | fr) & ext) ; cumul-fence* ; [Marked] ; rfe? ; [Marked]
let hb = [Marked] ; (ppo | rfe | prop ; strong-sync) ; [Marked]

acyclic po-loc | rf | co | fr
empty rmw & (fre ; coe)
acyclic hb

irreflexive (prop ; ppo*)
